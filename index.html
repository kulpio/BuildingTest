<!doctype html>
<html lang="en">
  <head>
    <title>Hotel Building Navigator</title>
    <meta charset="utf-8">
    <meta name="description" content="3D Hotel Building Navigator">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link type="text/css" href="./styles.css" rel="stylesheet"/>
  </head>
  <body>
    <!-- <model-viewer> HTML element -->
    <model-viewer 
      id="buildingViewer"
      src="MiniMapBuildingTest3.glb" 
      camera-controls 
      tone-mapping="neutral" 
      poster="poster.webp" 
      shadow-intensity="1" 
      camera-orbit="122.3deg 78.35deg 48.92m" 
      field-of-view="30deg"
      auto-rotate
      auto-rotate-delay="2000"
      interaction-prompt="none">
      
      <!-- Hotspot 1: Suite 1001 -->
      <button class="Hotspot" 
              slot="hotspot-1" 
              data-position="0.051192494287335896m 4.216019630432129m -2.143919160945778m" 
              data-normal="0m 1m 0m" 
              data-visibility-attribute="visible" 
              onclick="navigateTo('suite_1001')">
        <div class="HotspotAnnotation">Suite 1001</div>
      </button>
      
      <!-- Hotspot 2: Pool -->
      <button class="Hotspot" 
              slot="hotspot-2" 
              data-position="-1.3066787534509077m 1m -16.712600573634223m" 
              data-normal="0m 1m 0m" 
              data-visibility-attribute="visible" 
              onclick="navigateTo('pool')">
        <div class="HotspotAnnotation">Pool</div>
      </button>
      
      <!-- Loading Progress Bar -->
      <div class="progress-bar hide" slot="progress-bar">
        <div class="update-bar"></div>
      </div>
      
    </model-viewer>  
    
    <!-- Original script.js -->
    <script src="script.js"></script>
    
    <!-- Load model-viewer library -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
    
    <!-- 3DVista Navigation Script -->
    <script>
      function navigateTo(locationId) {
        console.log('🎯 Navigating to:', locationId);
        
        // Method 1: Hash navigation for 3DVista
        if (window.parent && window.parent !== window) {
          try {
            window.parent.location.hash = 'media=' + locationId;
            console.log('✅ Hash navigation sent:', 'media=' + locationId);
          } catch (e) {
            console.warn('⚠️ Hash navigation blocked:', e);
          }
        }
        
        // Method 2: PostMessage API (backup)
        window.parent.postMessage({
          action: 'navigate',
          target: locationId,
          type: 'vistaTour'
        }, '*');
        console.log('✅ PostMessage sent:', locationId);
        
        // Visual feedback
        const modelViewer = document.querySelector('model-viewer');
        if (modelViewer) {
          modelViewer.style.transition = 'opacity 0.2s ease';
          modelViewer.style.opacity = '0.8';
          setTimeout(() => {
            modelViewer.style.opacity = '1';
          }, 200);
        }
      }
      
      // Auto-rotate behavior: stop on interaction, resume after 5 seconds
      const viewer = document.querySelector('model-viewer');
      let interactionTimeout;
      
      viewer.addEventListener('camera-change', () => {
        viewer.autoRotate = false;
        clearTimeout(interactionTimeout);
        interactionTimeout = setTimeout(() => {
          viewer.autoRotate = true;
        }, 5000);
      });
      
      // Debug logging
      console.log('🏨 Hotel Building Navigator loaded');
      console.log('📍 Hotspots configured:', ['suite_1001', 'pool']);
      console.log('🎬 Ready for 3DVista integration');
    </script>
    
    <!-- Model Inspection & Tan Hover Glow Effect Script -->
    <script type="module">
      const modelViewer = document.getElementById('buildingViewer');
      
      let hoveredMesh = null;
      let originalMaterials = new Map();
      let meshes = [];
      let THREE = null;
      let scene = null;
      let camera = null;
      let Raycaster = null;
      let Vector2 = null;
      
      // Wait for model to load
      modelViewer.addEventListener('load', async () => {
        console.log('🏗️ Model loaded! Searching for scene...');
        
        try {
          // Explore all symbols to find the scene
          const symbols = Object.getOwnPropertySymbols(modelViewer);
          
          // Try to find scene
          for (const symbol of symbols) {
            const value = modelViewer[symbol];
            const desc = symbol.description || symbol.toString();
            
            if (desc === 'scene') {
              console.log('📦 Found scene:', desc);
              if (value && value.model) {
                scene = value.model;
                console.log('✅ Got model from scene');
              }
            }
            
            if (desc.includes('camera') && value && typeof value === 'object') {
              camera = value;
              console.log('📷 Found camera:', desc);
            }
          }
          
          // If we found the scene, traverse it
          if (scene && scene.children) {
            console.log('🌳 Scene has', scene.children.length, 'children');
            
            // Recursive function to find all meshes
            function findMeshes(object, depth = 0) {
              const indent = '  '.repeat(depth);
              const icon = object.isMesh ? '🔷' : '📁';
              console.log(`${indent}${icon} ${object.name || 'Unnamed'} (${object.type || 'Object'})`);
              
              if (object.isMesh && object.material) {
                meshes.push(object);
                
                // Store original material
                originalMaterials.set(object, {
                  color: object.material.color ? object.material.color.clone() : null,
                  emissive: object.material.emissive ? object.material.emissive.clone() : null
                });
                
                console.log(`${indent}  ├─ Material: ${object.material.name || 'Unnamed'}`);
                if (object.material.color) {
                  console.log(`${indent}  └─ Color: #${object.material.color.getHexString()}`);
                }
              }
              
              if (object.children && object.children.length > 0) {
                object.children.forEach(child => findMeshes(child, depth + 1));
              }
            }
            
            console.log('🌳 Scene Tree:');
            findMeshes(scene);
            
            console.log('📊 Summary:');
            console.log('  ├─ Total meshes:', meshes.length);
            console.log('  └─ Total materials:', originalMaterials.size);
            
            if (meshes.length > 0 && camera) {
              // Get THREE from the first mesh's constructor's parent
              // THREE.js classes all inherit from Object3D
              if (meshes[0] && meshes[0].constructor) {
                // Try to get Raycaster from the mesh's geometry constructor
                const geometryProto = meshes[0].geometry.constructor.prototype;
                const meshProto = meshes[0].constructor.prototype;
                
                // Walk up the prototype chain to find THREE
                let proto = meshes[0].constructor;
                while (proto) {
                  if (proto.Raycaster) {
                    Raycaster = proto.Raycaster;
                    Vector2 = proto.Vector2;
                    console.log('✅ Found Raycaster in proto chain');
                    break;
                  }
                  proto = Object.getPrototypeOf(proto);
                }
                
                // Alternative: Try to import from the mesh
                if (!Raycaster) {
                  // Get the module that contains THREE
                  const meshConstructor = meshes[0].constructor;
                  
                  // Access Raycaster through the window if available
                  if (window.THREE && window.THREE.Raycaster) {
                    Raycaster = window.THREE.Raycaster;
                    Vector2 = window.THREE.Vector2;
                    console.log('✅ Found THREE in window');
                  } else {
                    // Create Raycaster from scratch using the mesh's module
                    // Import from @google/model-viewer
                    import('https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js').then(module => {
                      // This won't work, but let's try manual raycasting
                      console.log('⚠️ Using manual raycasting (no THREE.Raycaster)');
                      setupManualHoverDetection();
                    });
                    return;
                  }
                }
              }
              
              console.log('✅ Ready for tan hover glow!');
              setupHoverDetection();
            } else {
              console.warn('⚠️ Missing meshes or camera');
            }
          } else {
            console.error('❌ Could not find scene with children');
          }
          
        } catch (error) {
          console.error('❌ Error:', error);
        }
      });
      
      function setupHoverDetection() {
        if (!Raycaster || !Vector2 || !camera || meshes.length === 0) {
          console.warn('⚠️ Missing requirements, trying manual detection');
          setupManualHoverDetection();
          return;
        }
        
        try {
          const raycaster = new Raycaster();
          const mouse = new Vector2();
          
          // Mouse move handler
          modelViewer.addEventListener('mousemove', (event) => {
            const rect = modelViewer.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            mouse.x = (x / rect.width) * 2 - 1;
            mouse.y = -(y / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshes, false);
            
            if (intersects.length > 0) {
              const intersectedMesh = intersects[0].object;
              
              if (intersectedMesh !== hoveredMesh) {
                // Reset previous
                if (hoveredMesh) {
                  const original = originalMaterials.get(hoveredMesh);
                  if (original && original.color && hoveredMesh.material.color) {
                    hoveredMesh.material.color.copy(original.color);
                  }
                  if (original && original.emissive && hoveredMesh.material.emissive) {
                    hoveredMesh.material.emissive.copy(original.emissive);
                  } else if (hoveredMesh.material.emissive) {
                    hoveredMesh.material.emissive.setRGB(0, 0, 0);
                  }
                }
                
                // Apply TAN GLOW
                hoveredMesh = intersectedMesh;
                if (hoveredMesh.material.color) {
                  hoveredMesh.material.color.setHex(0xD2B48C); // Tan
                }
                if (hoveredMesh.material.emissive) {
                  hoveredMesh.material.emissive.setHex(0xC19A6B); // Tan glow
                }
                
                console.log('🖱️ Hovering:', hoveredMesh.name || 'Unnamed');
                modelViewer.style.cursor = 'pointer';
              }
            } else {
              // Reset
              resetHover();
            }
          });
          
          // Mouse leave
          modelViewer.addEventListener('mouseleave', resetHover);
          
          console.log('✅ Hover detection enabled!');
        } catch (error) {
          console.error('❌ Raycaster error:', error);
          setupManualHoverDetection();
        }
      }
      
      function setupManualHoverDetection() {
        console.log('🔧 Setting up simplified hover detection...');
        
        // Simple hover effect - just highlight all meshes on mouse enter
        modelViewer.addEventListener('mouseenter', () => {
          meshes.forEach(mesh => {
            if (mesh.material && mesh.material.color) {
              mesh.material.color.setHex(0xD2B48C); // Tan
            }
            if (mesh.material && mesh.material.emissive) {
              mesh.material.emissive.setHex(0xC19A6B); // Tan glow
            }
          });
          modelViewer.style.cursor = 'pointer';
          console.log('🖱️ Mouse over model - all meshes highlighted');
        });
        
        modelViewer.addEventListener('mouseleave', () => {
          meshes.forEach(mesh => {
            const original = originalMaterials.get(mesh);
            if (original && original.color && mesh.material.color) {
              mesh.material.color.copy(original.color);
            }
            if (original && original.emissive && mesh.material.emissive) {
              mesh.material.emissive.copy(original.emissive);
            } else if (mesh.material.emissive) {
              mesh.material.emissive.setRGB(0, 0, 0);
            }
          });
          modelViewer.style.cursor = 'default';
          console.log('🖱️ Mouse left model - reset colors');
        });
        
        console.log('✅ Simplified hover enabled!');
      }
      
      function resetHover() {
        if (hoveredMesh) {
          const original = originalMaterials.get(hoveredMesh);
          if (original && original.color && hoveredMesh.material.color) {
            hoveredMesh.material.color.copy(original.color);
          }
          if (original && original.emissive && hoveredMesh.material.emissive) {
            hoveredMesh.material.emissive.copy(original.emissive);
          } else if (hoveredMesh.material.emissive) {
            hoveredMesh.material.emissive.setRGB(0, 0, 0);
          }
          hoveredMesh = null;
          modelViewer.style.cursor = 'default';
        }
      }
    </script>
    
  </body>
</html>
