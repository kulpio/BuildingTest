<!doctype html>
<html lang="en">
  <head>
    <title>Hotel Building Navigator</title>
    <meta charset="utf-8">
    <meta name="description" content="3D Hotel Building Navigator">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link type="text/css" href="./styles.css" rel="stylesheet"/>
  </head>
  <body>
    <!-- <model-viewer> HTML element -->
    <model-viewer 
      id="buildingViewer"
      src="MiniMapBuildingTest3.glb" 
      camera-controls 
      tone-mapping="neutral" 
      poster="poster.webp" 
      shadow-intensity="1" 
      camera-orbit="122.3deg 78.35deg 48.92m" 
      field-of-view="30deg"
      auto-rotate
      auto-rotate-delay="2000"
      interaction-prompt="none">
      
      <!-- Hotspot 1: Suite 1001 -->
      <button class="Hotspot" 
              slot="hotspot-1" 
              data-position="0.051192494287335896m 4.216019630432129m -2.143919160945778m" 
              data-normal="0m 1m 0m" 
              data-visibility-attribute="visible" 
              onclick="navigateTo('suite_1001')">
        <div class="HotspotAnnotation">Suite 1001</div>
      </button>
      
      <!-- Hotspot 2: Pool -->
      <button class="Hotspot" 
              slot="hotspot-2" 
              data-position="-1.3066787534509077m 1m -16.712600573634223m" 
              data-normal="0m 1m 0m" 
              data-visibility-attribute="visible" 
              onclick="navigateTo('pool')">
        <div class="HotspotAnnotation">Pool</div>
      </button>
      
      <!-- Loading Progress Bar -->
      <div class="progress-bar hide" slot="progress-bar">
        <div class="update-bar"></div>
      </div>
      
    </model-viewer>  
    
    <!-- Original script.js -->
    <script src="script.js"></script>
    
    <!-- Load model-viewer library -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
    
    <!-- 3DVista Navigation Script -->
    <script>
      function navigateTo(locationId) {
        console.log('üéØ Navigating to:', locationId);
        
        // Method 1: Hash navigation for 3DVista
        if (window.parent && window.parent !== window) {
          try {
            window.parent.location.hash = 'media=' + locationId;
            console.log('‚úÖ Hash navigation sent:', 'media=' + locationId);
          } catch (e) {
            console.warn('‚ö†Ô∏è Hash navigation blocked:', e);
          }
        }
        
        // Method 2: PostMessage API (backup)
        window.parent.postMessage({
          action: 'navigate',
          target: locationId,
          type: 'vistaTour'
        }, '*');
        console.log('‚úÖ PostMessage sent:', locationId);
        
        // Visual feedback
        const modelViewer = document.querySelector('model-viewer');
        if (modelViewer) {
          modelViewer.style.transition = 'opacity 0.2s ease';
          modelViewer.style.opacity = '0.8';
          setTimeout(() => {
            modelViewer.style.opacity = '1';
          }, 200);
        }
      }
      
      // Auto-rotate behavior: stop on interaction, resume after 5 seconds
      const viewer = document.querySelector('model-viewer');
      let interactionTimeout;
      
      viewer.addEventListener('camera-change', () => {
        viewer.autoRotate = false;
        clearTimeout(interactionTimeout);
        interactionTimeout = setTimeout(() => {
          viewer.autoRotate = true;
        }, 5000);
      });
      
      // Debug logging
      console.log('üè® Hotel Building Navigator loaded');
      console.log('üìç Hotspots configured:', ['suite_1001', 'pool']);
      console.log('üé¨ Ready for 3DVista integration');
    </script>
    
    <!-- Model-Only Hover Detection with Continuous Rendering -->
    <script type="module">
      const modelViewer = document.getElementById('buildingViewer');
      
      let hoveredMesh = null;
      let originalMaterials = new Map();
      let firstFloor = null;
      let secondFloor = null;
      let renderLoopActive = false;
      let midY = 0; // Midpoint Y between floors
      
      // Continuous render loop
      function startRenderLoop() {
        if (renderLoopActive) return;
        renderLoopActive = true;
        
        function animate() {
          const orbit = modelViewer.getCameraOrbit();
          const nudge = Math.sin(Date.now() / 10000) * 0.00001;
          modelViewer.cameraOrbit = `${orbit.theta + nudge}rad ${orbit.phi}rad ${orbit.radius}m`;
          requestAnimationFrame(animate);
        }
        
        animate();
        console.log('üîÑ Continuous render loop started');
      }
      
      // Wait for model to load
      modelViewer.addEventListener('load', async () => {
        console.log('üèóÔ∏è Model loaded! Finding meshes...');
        
        try {
          // Find scene
          const symbols = Object.getOwnPropertySymbols(modelViewer);
          let scene = null;
          
          for (const symbol of symbols) {
            const value = modelViewer[symbol];
            const desc = symbol.description || symbol.toString();
            
            if (desc === 'scene' && value && value.model) {
              scene = value.model;
              break;
            }
          }
          
          if (scene && scene.children) {
            // Find meshes
            function findMeshes(object) {
              if (object.isMesh && object.material) {
                // Store original material
                originalMaterials.set(object, {
                  color: object.material.color ? object.material.color.clone() : null,
                  emissive: object.material.emissive ? object.material.emissive.clone() : null
                });
                
                // Assign floors
                if (object.name && object.name.includes('first')) {
                  firstFloor = object;
                  console.log('‚úÖ Found first_floor at Y:', object.position?.y || 'N/A');
                } else if (object.name && object.name.includes('second')) {
                  secondFloor = object;
                  console.log('‚úÖ Found second_floor at Y:', object.position?.y || 'N/A');
                }
              }
              
              if (object.children && object.children.length > 0) {
                object.children.forEach(child => findMeshes(child));
              }
            }
            
            findMeshes(scene);
            
            if (firstFloor && secondFloor) {
              // Calculate midpoint between floors
              const firstY = firstFloor.position?.y || 0;
              const secondY = secondFloor.position?.y || 1;
              midY = (firstY + secondY) / 2;
              
              console.log('üìè Floor midpoint Y:', midY);
              console.log('‚úÖ Ready for model-only hover!');
              
              startRenderLoop();
              setupModelHover();
            }
          }
          
        } catch (error) {
          console.error('‚ùå Error:', error);
        }
      });
      
      function setupModelHover() {
        console.log('üîß Setting up MODEL-ONLY hover detection...');
        console.log('   Only glows when cursor is over 3D model');
        
        // Mouse move handler
        modelViewer.addEventListener('mousemove', (event) => {
          const rect = modelViewer.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          
          // Convert to normalized coordinates
          const normalizedX = (x / rect.width) * 2 - 1;
          const normalizedY = -(y / rect.height) * 2 + 1;
          
          // Check if we're actually hitting the model
          const hit = modelViewer.positionAndNormalFromPoint(normalizedX, normalizedY);
          
          if (hit) {
            // We're over the model! Determine which floor
            const hitY = hit.position.y;
            const targetMesh = hitY > midY ? secondFloor : firstFloor;
            
            // If different from current hover
            if (targetMesh && targetMesh !== hoveredMesh) {
              // Reset previous
              if (hoveredMesh) {
                resetMesh(hoveredMesh);
              }
              
              // Apply TAN GLOW
              hoveredMesh = targetMesh;
              
              if (hoveredMesh.material) {
                if (hoveredMesh.material.color) {
                  hoveredMesh.material.color.setHex(0xF4E4C1); // Bright tan
                }
                
                if (hoveredMesh.material.emissive) {
                  hoveredMesh.material.emissive.setHex(0xD2A679); // Tan glow
                  if (hoveredMesh.material.emissiveIntensity !== undefined) {
                    hoveredMesh.material.emissiveIntensity = 0.5;
                  }
                }
                
                hoveredMesh.material.needsUpdate = true;
              }
              
              console.log('‚ú® GLOWING:', hoveredMesh.name, `(hitY: ${hitY.toFixed(2)})`);
              modelViewer.style.cursor = 'pointer';
            }
          } else {
            // NOT over the model - reset everything
            if (hoveredMesh) {
              console.log('‚ùå Cursor left model - resetting');
              resetMesh(hoveredMesh);
              hoveredMesh = null;
              modelViewer.style.cursor = 'default';
            }
          }
        });
        
        // Mouse leave viewer
        modelViewer.addEventListener('mouseleave', () => {
          if (hoveredMesh) {
            console.log('üëã Mouse left viewer');
            resetMesh(hoveredMesh);
            hoveredMesh = null;
            modelViewer.style.cursor = 'default';
          }
        });
        
        console.log('‚úÖ Model-only hover enabled!');
      }
      
      function resetMesh(mesh) {
        const original = originalMaterials.get(mesh);
        if (original && mesh.material) {
          if (original.color && mesh.material.color) {
            mesh.material.color.copy(original.color);
          }
          if (original.emissive && mesh.material.emissive) {
            mesh.material.emissive.copy(original.emissive);
          } else if (mesh.material.emissive) {
            mesh.material.emissive.setRGB(0, 0, 0);
          }
          
          if (mesh.material.emissiveIntensity !== undefined) {
            mesh.material.emissiveIntensity = 1.0;
          }
          
          mesh.material.needsUpdate = true;
        }
      }
    </script>
    
  </body>
</html>
