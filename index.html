<!doctype html>
<html lang="en">
  <head>
    <title>Hotel Building Navigator</title>
    <meta charset="utf-8">
    <meta name="description" content="3D Hotel Building Navigator">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link type="text/css" href="./styles.css" rel="stylesheet"/>
  </head>
  <body>
    <!-- <model-viewer> HTML element -->
    <model-viewer 
      id="buildingViewer"
      src="MiniMapBuildingTest3.glb" 
      camera-controls 
      tone-mapping="neutral" 
      poster="poster.webp" 
      shadow-intensity="1" 
      camera-orbit="122.3deg 78.35deg 48.92m" 
      field-of-view="30deg"
      auto-rotate
      auto-rotate-delay="2000"
      interaction-prompt="none">
      
      <!-- Hotspot 1: Suite 1001 -->
      <button class="Hotspot" 
              slot="hotspot-1" 
              data-position="0.051192494287335896m 4.216019630432129m -2.143919160945778m" 
              data-normal="0m 1m 0m" 
              data-visibility-attribute="visible" 
              onclick="navigateTo('suite_1001')">
        <div class="HotspotAnnotation">Suite 1001</div>
      </button>
      
      <!-- Hotspot 2: Pool -->
      <button class="Hotspot" 
              slot="hotspot-2" 
              data-position="-1.3066787534509077m 1m -16.712600573634223m" 
              data-normal="0m 1m 0m" 
              data-visibility-attribute="visible" 
              onclick="navigateTo('pool')">
        <div class="HotspotAnnotation">Pool</div>
      </button>
      
      <!-- Loading Progress Bar -->
      <div class="progress-bar hide" slot="progress-bar">
        <div class="update-bar"></div>
      </div>
      
    </model-viewer>  
    
    <!-- Original script.js -->
    <script src="script.js"></script>
    
    <!-- Load model-viewer library -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
    
    <!-- Load Three.js separately for raycasting -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.min.js"></script>
    
    <!-- 3DVista Navigation Script -->
    <script>
      function navigateTo(locationId) {
        console.log('ğŸ¯ Navigating to:', locationId);
        
        // Method 1: Hash navigation for 3DVista
        if (window.parent && window.parent !== window) {
          try {
            window.parent.location.hash = 'media=' + locationId;
            console.log('âœ… Hash navigation sent:', 'media=' + locationId);
          } catch (e) {
            console.warn('âš ï¸ Hash navigation blocked:', e);
          }
        }
        
        // Method 2: PostMessage API (backup)
        window.parent.postMessage({
          action: 'navigate',
          target: locationId,
          type: 'vistaTour'
        }, '*');
        console.log('âœ… PostMessage sent:', locationId);
        
        // Visual feedback
        const modelViewer = document.querySelector('model-viewer');
        if (modelViewer) {
          modelViewer.style.transition = 'opacity 0.2s ease';
          modelViewer.style.opacity = '0.8';
          setTimeout(() => {
            modelViewer.style.opacity = '1';
          }, 200);
        }
      }
      
      // Auto-rotate behavior: stop on interaction, resume after 5 seconds
      const viewer = document.querySelector('model-viewer');
      let interactionTimeout;
      
      viewer.addEventListener('camera-change', () => {
        viewer.autoRotate = false;
        clearTimeout(interactionTimeout);
        interactionTimeout = setTimeout(() => {
          viewer.autoRotate = true;
        }, 5000);
      });
      
      // Debug logging
      console.log('ğŸ¨ Hotel Building Navigator loaded');
      console.log('ğŸ“ Hotspots configured:', ['suite_1001', 'pool']);
      console.log('ğŸ¬ Ready for 3DVista integration');
    </script>
    
    <!-- Model Inspection & Tan Hover Glow Effect Script -->
    <script>
      const modelViewer = document.getElementById('buildingViewer');
      
      let hoveredMesh = null;
      let originalMaterials = new Map();
      let meshes = [];
      let raycaster, mouse;
      
      // Wait for both model-viewer and THREE.js to be ready
      async function initHoverEffect() {
        // Wait for THREE.js to be available
        while (typeof THREE === 'undefined') {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        console.log('âœ… THREE.js loaded');
        
        // Initialize raycaster
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        
        // Wait for model to load
        await modelViewer.loaded;
        
        console.log('ğŸ—ï¸ Model loaded! Inspecting structure...');
        
        const model = modelViewer.model;
        
        // Check if model has traverse method
        if (!model || typeof model.traverse !== 'function') {
          console.error('âŒ Model does not have traverse method');
          console.log('Model object:', model);
          return;
        }
        
        console.log('ğŸ“¦ Full Model Object:', model);
        
        // Function to recursively print the tree
        function printTree(object, indent = '', index = 0) {
          const icon = object.isMesh ? 'ğŸ”·' : object.isGroup ? 'ğŸ“' : 'ğŸ“¦';
          console.log(`${indent}${icon} [${index}] ${object.name || 'Unnamed'} (${object.type})`);
          
          if (object.isMesh && object.material) {
            console.log(`${indent}  â”œâ”€ Material: ${object.material.name || 'Unnamed'}`);
            console.log(`${indent}  â”œâ”€ Color: ${object.material.color ? '#' + object.material.color.getHexString() : 'N/A'}`);
            console.log(`${indent}  â””â”€ Geometry: ${object.geometry.type}`);
          }
          
          if (object.children && object.children.length > 0) {
            object.children.forEach((child, i) => {
              printTree(child, indent + '  ', i);
            });
          }
        }
        
        console.log('ğŸŒ³ Scene Tree Structure:');
        printTree(model);
        
        // Get all meshes and store their original materials
        model.traverse((node) => {
          if (node.isMesh && node.material) {
            meshes.push(node);
            
            // Store original material properties
            originalMaterials.set(node, {
              color: node.material.color.clone(),
              emissive: node.material.emissive ? node.material.emissive.clone() : new THREE.Color(0, 0, 0)
            });
            
            console.log('ğŸ”· Mesh found:', {
              name: node.name || 'Unnamed',
              material: node.material.name || 'Unnamed',
              color: node.material.color ? '#' + node.material.color.getHexString() : 'N/A'
            });
          }
        });
        
        console.log('ğŸ“Š Summary:');
        console.log('  â”œâ”€ Total meshes:', meshes.length);
        console.log('  â”œâ”€ Total materials:', originalMaterials.size);
        console.log('  â””â”€ Ready for tan hover glow!');
        
        // Enable hover detection
        setupHoverDetection();
      }
      
      function setupHoverDetection() {
        // Get camera from model-viewer
        const getCamera = () => {
          const symbols = Object.getOwnPropertySymbols(modelViewer);
          const cameraSymbol = symbols.find(s => s.description === 'camera');
          return cameraSymbol ? modelViewer[cameraSymbol] : null;
        };
        
        // Mouse move handler
        modelViewer.addEventListener('mousemove', (event) => {
          const rect = modelViewer.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          
          // Convert to normalized device coordinates
          mouse.x = (x / rect.width) * 2 - 1;
          mouse.y = -(y / rect.height) * 2 + 1;
          
          // Get camera
          const camera = getCamera();
          if (!camera) {
            console.warn('âš ï¸ Camera not found');
            return;
          }
          
          // Perform raycasting
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(meshes, false);
          
          if (intersects.length > 0) {
            const intersectedMesh = intersects[0].object;
            
            // If hovering over a new mesh
            if (intersectedMesh !== hoveredMesh) {
              // Reset previous mesh
              if (hoveredMesh) {
                const original = originalMaterials.get(hoveredMesh);
                if (original) {
                  hoveredMesh.material.color.copy(original.color);
                  hoveredMesh.material.emissive.copy(original.emissive);
                }
              }
              
              // Set new hovered mesh with TAN GLOW
              hoveredMesh = intersectedMesh;
              hoveredMesh.material.color.setHex(0xD2B48C); // Tan color
              hoveredMesh.material.emissive.setHex(0xC19A6B); // Warm tan glow
              
              console.log('ğŸ–±ï¸ Hovering:', hoveredMesh.name || 'Unnamed mesh');
              modelViewer.style.cursor = 'pointer';
            }
          } else {
            // No intersection - reset
            if (hoveredMesh) {
              const original = originalMaterials.get(hoveredMesh);
              if (original) {
                hoveredMesh.material.color.copy(original.color);
                hoveredMesh.material.emissive.copy(original.emissive);
              }
              hoveredMesh = null;
              modelViewer.style.cursor = 'default';
            }
          }
        });
        
        // Reset on mouse leave
        modelViewer.addEventListener('mouseleave', () => {
          if (hoveredMesh) {
            const original = originalMaterials.get(hoveredMesh);
            if (original) {
              hoveredMesh.material.color.copy(original.color);
              hoveredMesh.material.emissive.copy(original.emissive);
            }
            hoveredMesh = null;
            modelViewer.style.cursor = 'default';
          }
        });
        
        console.log('âœ… Hover detection enabled!');
      }
      
      // Initialize when ready
      initHoverEffect().catch(err => {
        console.error('âŒ Failed to initialize hover effect:', err);
      });
    </script>
    
  </body>
</html>
